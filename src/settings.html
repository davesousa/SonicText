<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>SonicText Settings</title>
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>
    <div class="settings-container">
        <div class="header">
            <h2>Settings <span style="font-size: 0.6em; color: var(--accent-color); font-weight: normal;">v1.1.3</span></h2>
            <button class="close-button" id="closeButton">Ã—</button>
        </div>
        <div class="settings-grid">
            <div class="setting-group">
                <label class="setting-label" for="hotkeyInput">Global Hotkey</label>
                <input type="text" id="hotkeyInput" class="hotkey-input" placeholder="Press keys..." readonly>
                <div class="hint-text">Click to change the hotkey combination</div>
            </div>
            <div class="setting-group">
                <label class="setting-label" for="apiKeyInput">OpenAI API Key</label>
                <input type="password" id="apiKeyInput" class="settings-input" placeholder="Enter your OpenAI API key">
                <div class="hint-text">Get your API key from: <a href="#" onclick="openApiKeyPage()">OpenAI Dashboard</a></div>
            </div>
            <div class="setting-group">
                <label class="setting-label" for="deviceSelect">Input Device</label>
                <select id="deviceSelect" class="device-select"></select>
                <div class="hint-text">Select your preferred microphone</div>
            </div>
            <div class="setting-group">
                <label class="setting-label" for="languageSelect">Language</label>
                <select id="languageSelect" class="device-select">
                    <option value="en">English</option>
                    <option value="es">Spanish</option>
                    <option value="fr">French</option>
                    <option value="de">German</option>
                    <option value="it">Italian</option>
                    <option value="pt">Portuguese</option>
                    <option value="nl">Dutch</option>
                    <option value="ja">Japanese</option>
                    <option value="ko">Korean</option>
                    <option value="zh">Chinese</option>
                </select>
                <div class="hint-text">Select transcription language</div>
            </div>
            <div class="setting-group">
                <label class="setting-label">Theme</label>
                <select id="themeSelect" class="device-select">
                    <option value="dark">Dark</option>
                    <option value="light">Light</option>
                </select>
                <div class="hint-text">Customize the app's appearance</div>
            </div>
            <div class="save-indicator" id="saveIndicator">Settings saved!</div>
        </div>
    </div>
    <script>
        const { ipcRenderer } = require('electron');
        const hotkeyInput = document.getElementById('hotkeyInput');
        const deviceSelect = document.getElementById('deviceSelect');
        const closeButton = document.getElementById('closeButton');
        const saveIndicator = document.getElementById('saveIndicator');
        const themeSelect = document.getElementById('themeSelect');
        const languageSelect = document.getElementById('languageSelect');
        const apiKeyInput = document.getElementById('apiKeyInput');
        let currentHotkey = '';
        let recordingKeys = false;
        let pressedKeys = new Set();
        let saveTimeout = null;

        // Get available audio devices
        async function loadAudioDevices() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioDevices = devices.filter(device => device.kind === 'audioinput');
                
                // Clear existing options
                deviceSelect.innerHTML = '';
                
                // Add devices to select
                audioDevices.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.text = device.label || `Microphone ${device.deviceId.slice(0, 5)}...`;
                    deviceSelect.appendChild(option);
                });

                // Get current device from main process
                ipcRenderer.send('get-current-device');
            } catch (error) {
                console.error('Error loading audio devices:', error);
                deviceSelect.innerHTML = '<option value="">Error loading devices</option>';
            }
        }

        function showSaveIndicator() {
            saveIndicator.classList.add('visible');
            if (saveTimeout) clearTimeout(saveTimeout);
            saveTimeout = setTimeout(() => {
                saveIndicator.classList.remove('visible');
            }, 2000);
        }

        // Load devices when permissions are granted
        navigator.mediaDevices.getUserMedia({ audio: true })
            .then(() => loadAudioDevices())
            .catch(error => {
                console.error('Error getting audio permissions:', error);
                deviceSelect.innerHTML = '<option value="">No microphone access</option>';
            });

        // Handle device selection
        deviceSelect.addEventListener('change', () => {
            const deviceId = deviceSelect.value;
            ipcRenderer.send('update-device', deviceId);
            showSaveIndicator();
        });

        // Get current device from main process
        ipcRenderer.on('current-device', (event, deviceId) => {
            if (deviceId && deviceSelect.querySelector(`option[value="${deviceId}"]`)) {
                deviceSelect.value = deviceId;
            }
        });

        // Handle hotkey recording
        hotkeyInput.addEventListener('focus', () => {
            recordingKeys = true;
            pressedKeys.clear();
            hotkeyInput.value = '';
        });

        hotkeyInput.addEventListener('blur', () => {
            recordingKeys = false;
            if (!hotkeyInput.value) {
                hotkeyInput.value = currentHotkey;
            }
        });

        document.addEventListener('keydown', (e) => {
            if (!recordingKeys) return;
            e.preventDefault();

            const key = e.key.toLowerCase();
            const keyMap = {
                'control': 'CommandOrControl',
                'meta': 'CommandOrControl',
                'alt': 'Alt',
                'shift': 'Shift',
                'escape': 'Esc',
                'return': 'Return',
                'enter': 'Return',
                ' ': 'Space'
            };

            const mappedKey = keyMap[key] || key.length === 1 ? key.toUpperCase() : key;
            
            if (key === 'control' || key === 'shift' || key === 'alt' || key === 'meta' || key.length === 1 || keyMap[key]) {
                pressedKeys.add(mappedKey);
            }

            const keys = Array.from(pressedKeys);
            if (keys.length > 0) {
                hotkeyInput.value = keys.join('+');
            }
        });

        document.addEventListener('keyup', (e) => {
            if (!recordingKeys) return;
            const key = e.key.toLowerCase();
            const keyMap = {
                'control': 'CommandOrControl',
                'meta': 'CommandOrControl',
                'alt': 'Alt',
                'shift': 'Shift',
                'escape': 'Esc',
                'return': 'Return',
                'enter': 'Return',
                ' ': 'Space'
            };
            const mappedKey = keyMap[key] || key.length === 1 ? key.toUpperCase() : key;
            pressedKeys.delete(mappedKey);

            if (pressedKeys.size === 0 && hotkeyInput.value && hotkeyInput.value !== currentHotkey) {
                const newHotkey = hotkeyInput.value;
                currentHotkey = newHotkey;
                ipcRenderer.send('update-hotkey', newHotkey);
                showSaveIndicator();
            }
        });

        // Get current hotkey
        ipcRenderer.send('get-current-hotkey');
        ipcRenderer.on('current-hotkey', (event, hotkey) => {
            currentHotkey = hotkey;
            hotkeyInput.value = hotkey;
        });

        // Handle theme changes
        themeSelect.addEventListener('change', () => {
            const theme = themeSelect.value;
            if (theme === 'light') {
                document.body.classList.add('light-theme');
            } else {
                document.body.classList.remove('light-theme');
            }
            ipcRenderer.send('update-theme', theme);
            showSaveIndicator();
        });

        // Handle language changes
        languageSelect.addEventListener('change', () => {
            const language = languageSelect.value;
            ipcRenderer.send('update-language', language);
            showSaveIndicator();
        });

        // Get current theme and language
        ipcRenderer.send('get-theme');
        ipcRenderer.send('get-language');

        ipcRenderer.on('current-theme', (event, theme) => {
            themeSelect.value = theme;
            if (theme === 'light') {
                document.body.classList.add('light-theme');
            } else {
                document.body.classList.remove('light-theme');
            }
        });

        ipcRenderer.on('current-language', (event, language) => {
            languageSelect.value = language || 'en';
        });

        // Handle API key
        ipcRenderer.send('get-api-key');
        
        ipcRenderer.on('current-api-key', (event, apiKey) => {
            apiKeyInput.value = apiKey || '';
        });

        apiKeyInput.addEventListener('input', () => {
            ipcRenderer.send('update-api-key', apiKeyInput.value);
            showSaveIndicator();
        });

        // Handle close button
        closeButton.addEventListener('click', () => {
            ipcRenderer.send('close-settings');
        });

        function openApiKeyPage() {
            require('electron').shell.openExternal('https://platform.openai.com/api-keys');
        }
    </script>
</body>
</html> 