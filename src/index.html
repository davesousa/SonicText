<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>SonicText</title>
    <link rel="stylesheet" href="css/styles.css">
</head>
<body class="transparent-bg">
    <div class="status-pill">
        <div id="indicator">
            <svg id="mic-icon" viewBox="0 0 24 24">
                <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm-1-9c0-.55.45-1 1-1s1 .45 1 1v6c0 .55-.45 1-1 1s-1-.45-1-1V5z"/>
                <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>
            </svg>
        </div>
        <div id="visualizer">
            <div class="visualizer-bar"></div>
            <div class="visualizer-bar"></div>
            <div class="visualizer-bar"></div>
            <div class="visualizer-bar"></div>
            <div class="visualizer-bar"></div>
        </div>
        <span id="status-text">Waiting...</span>
        <svg id="optimize-icon" viewBox="0 0 24 24">
            <path d="M12.6 2.4c-.4-.3-.9-.3-1.2 0C9.5 3.9 8 6.2 8 9c0 1.1.3 2.1.8 3H6c-.6 0-1 .4-1 1v2c0 .6.4 1 1 1h1v2c0 .6.4 1 1 1h2v2c0 .6.4 1 1 1h2c.6 0 1-.4 1-1v-2h2c.6 0 1-.4 1-1v-2h1c.6 0 1-.4 1-1v-2c0-.6-.4-1-1-1h-2.8c.5-.9.8-1.9.8-3 0-2.8-1.5-5.1-3.4-6.6zM12 8c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2z"/>
        </svg>
        <svg id="history-icon" viewBox="0 0 24 24">
            <path d="M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z"/>
        </svg>
        <svg id="settings-icon" viewBox="0 0 24 24">
            <path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/>
        </svg>
    </div>
    <div id="result" class="result-box"></div>
    <script>
        const { ipcRenderer } = require('electron');
        const indicator = document.getElementById('indicator');
        const statusText = document.getElementById('status-text');
        let isActive = false;
        let isProcessing = false;
        let audioContext = null;
        let analyser = null;
        let microphone = null;
        let animationFrame = null;
        let mediaRecorder = null;
        let audioChunks = [];
        let audioStream = null;
        let lastVolume = 0;
        let processingTimeout = null;
        let currentDeviceId = '';

        async function setupAudio() {
            try {
                if (audioStream) {
                    audioStream.getTracks().forEach(track => track.stop());
                }
                
                const constraints = { 
                    audio: {
                        channelCount: 1,
                        sampleRate: 16000,
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: false
                    } 
                };

                // If we have a specific device selected, use it
                if (currentDeviceId) {
                    constraints.audio = {
                        ...constraints.audio,
                        deviceId: { exact: currentDeviceId }
                    };
                }
                
                audioStream = await navigator.mediaDevices.getUserMedia(constraints);
                
                if (audioContext) {
                    await audioContext.close();
                }
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                microphone = audioContext.createMediaStreamSource(audioStream);
                
                analyser.fftSize = 512;
                analyser.smoothingTimeConstant = 0.6;
                microphone.connect(analyser);

                mediaRecorder = new MediaRecorder(audioStream, {
                    mimeType: 'audio/webm',
                    audioBitsPerSecond: 128000
                });

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = async () => {
                    if (audioChunks.length > 0) {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        startProcessing();
                        
                        const arrayBuffer = await audioBlob.arrayBuffer();
                        const buffer = Buffer.from(arrayBuffer);
                        ipcRenderer.send('audio-recorded', buffer);
                        
                        audioChunks = [];
                    }
                };
                
                return true;
            } catch (error) {
                console.error('Error accessing microphone:', error);
                return false;
            }
        }

        function updateGlow() {
            if (!isActive || !analyser) return;

            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(dataArray);
            
            const voiceRange = dataArray.slice(1, 6);
            const average = voiceRange.reduce((a, b) => a + b) / voiceRange.length;
            
            const normalizedVolume = Math.pow(average / 128, 1.8);
            // Adjust smoothing ratio to favor new values more when volume is decreasing
            const smoothingRatio = normalizedVolume < lastVolume ? 0.6 : 0.4;
            const smoothedVolume = normalizedVolume * smoothingRatio + lastVolume * (1 - smoothingRatio);
            lastVolume = smoothedVolume;

            // Update visualizer bars with smoother transitions
            const bars = document.querySelectorAll('.visualizer-bar');
            const numBars = bars.length;
            for (let i = 0; i < numBars; i++) {
                const barIndex = Math.floor(i * (voiceRange.length / numBars));
                const value = voiceRange[barIndex] / 255;
                const targetHeight = Math.max(2, Math.min(32, value * 40));
                const currentHeight = parseFloat(bars[i].style.height) || 2;
                const heightSmoothingRatio = targetHeight < currentHeight ? 0.7 : 0.4;
                const smoothedHeight = currentHeight * (1 - heightSmoothingRatio) + targetHeight * heightSmoothingRatio;
                bars[i].style.height = `${smoothedHeight}px`;
                
                // Adjust glow intensity based on height
                const glowIntensity = (smoothedHeight - 2) / 30; // normalized 0-1 based on height
                const glowOpacity = 0.3 + (glowIntensity * 0.3); // range from 0.3 to 0.6
                const glowSize = 4 + (glowIntensity * 4); // range from 4px to 8px
                bars[i].style.boxShadow = `0 0 ${glowSize}px rgba(255, 255, 255, ${glowOpacity})`;
            }

            const minGlow = 8;
            const maxGlow = 20;
            const glowAmount = minGlow + (maxGlow * smoothedVolume);
            const minOpacity = 0.3;
            const maxOpacity = 0.8;
            const opacity = minOpacity + ((maxOpacity - minOpacity) * smoothedVolume);
            
            if (!isProcessing) {
                indicator.style.boxShadow = `0 0 ${glowAmount}px rgba(255, 0, 0, ${opacity})`;
            }

            if (isActive) {
                animationFrame = requestAnimationFrame(updateGlow);
            }
        }

        function startProcessing() {
            isProcessing = true;
            statusText.textContent = 'Processing...';
            indicator.classList.add('processing');
            
            // Simulate processing time (remove this when implementing actual API)
            processingTimeout = setTimeout(() => {
                endProcessing();
            }, 3000);
        }

        function endProcessing() {
            isProcessing = false;
            statusText.textContent = 'Waiting...';
            indicator.classList.remove('processing');
            indicator.style.boxShadow = 'none';
        }

        async function activate() {
            if (!isActive && !isProcessing) {
                isActive = true;
                statusText.style.display = 'none';
                document.getElementById('visualizer').classList.add('active');
                indicator.classList.add('active');
                
                try {
                    if (!audioContext || !mediaRecorder) {
                        await setupAudio();
                    } else if (audioContext.state === 'suspended') {
                        await audioContext.resume();
                    }
                    
                    if (mediaRecorder && mediaRecorder.state === 'inactive') {
                        audioChunks = [];
                        mediaRecorder.start();
                        updateGlow();
                    }
                } catch (error) {
                    console.error('Error activating audio:', error);
                    deactivate();
                }
            }
        }

        function deactivate() {
            if (isActive) {
                isActive = false;
                statusText.style.display = 'inline';
                document.getElementById('visualizer').classList.remove('active');
                indicator.classList.remove('active');
                
                // Reset visualizer bars
                const bars = document.querySelectorAll('.visualizer-bar');
                bars.forEach(bar => bar.style.height = '2px');
                
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                }
                
                if (animationFrame) {
                    cancelAnimationFrame(animationFrame);
                    animationFrame = null;
                }
                
                if (audioContext && audioContext.state === 'running') {
                    audioContext.suspend();
                }
            }
        }

        ipcRenderer.on('hotkey-pressed', activate);
        ipcRenderer.on('hotkey-released', deactivate);

        // Add result box handling
        const resultBox = document.getElementById('result');
        let resultTimeout = null;

        ipcRenderer.on('transcription-start', () => {
            statusText.textContent = 'Transcribing...';
            resultBox.classList.remove('error');
            resultBox.classList.add('visible');
        });

        ipcRenderer.on('optimization-start', () => {
            statusText.textContent = 'Optimizing...';
        });

        ipcRenderer.on('optimization-complete', () => {
            endProcessing();
        });

        ipcRenderer.on('optimization-error', (event, error) => {
            console.error('Optimization error:', error);
            endProcessing();
        });

        ipcRenderer.on('transcription-result', (event, text) => {
            resultBox.textContent = text;
            
            // Adjust window height based on content
            const totalHeight = document.body.scrollHeight + 20; // Add padding
            const maxHeight = 500;
            const newHeight = Math.min(totalHeight, maxHeight);
            ipcRenderer.send('adjust-window-height', newHeight);
            
            // Start hide timer if we're not optimizing
            if (!statusText.textContent.includes('Optimizing')) {
                if (resultTimeout) clearTimeout(resultTimeout);
                resultTimeout = setTimeout(() => {
                    resultBox.classList.remove('visible');
                    ipcRenderer.send('adjust-window-height', 100); // Reset to original height
                }, 15000); // Increased from 5000 to 15000 (15 seconds)
            }
        });

        ipcRenderer.on('transcription-error', (event, error) => {
            resultBox.textContent = `Error: ${error}`;
            resultBox.classList.add('error', 'visible');
            endProcessing();
            
            // Hide error after 3 seconds
            if (resultTimeout) clearTimeout(resultTimeout);
            resultTimeout = setTimeout(() => {
                resultBox.classList.remove('visible', 'error');
            }, 3000);
        });

        // Add settings icon click handler
        const settingsIcon = document.getElementById('settings-icon');
        const optimizeIcon = document.getElementById('optimize-icon');
        const historyIcon = document.getElementById('history-icon');
        
        settingsIcon.addEventListener('click', () => {
            ipcRenderer.send('toggle-settings');
        });

        optimizeIcon.addEventListener('click', () => {
            ipcRenderer.send('toggle-optimize');
        });

        historyIcon.addEventListener('click', () => {
            ipcRenderer.send('toggle-history');
        });

        // Handle optimization status changes
        ipcRenderer.on('optimize-status-changed', (event, enabled) => {
            if (enabled) {
                optimizeIcon.classList.add('active');
            } else {
                optimizeIcon.classList.remove('active');
            }
        });

        // Get initial optimization status
        ipcRenderer.send('get-optimize-settings');
        ipcRenderer.on('optimize-settings', (event, settings) => {
            if (settings.enabled) {
                optimizeIcon.classList.add('active');
            } else {
                optimizeIcon.classList.remove('active');
            }
        });

        // Add device change handler
        ipcRenderer.on('device-changed', async (event, deviceId) => {
            currentDeviceId = deviceId;
            if (isActive) {
                // If we're currently recording, stop and restart with new device
                const wasRecording = mediaRecorder?.state === 'recording';
                if (wasRecording) {
                    mediaRecorder.stop();
                }
                await setupAudio();
                if (wasRecording) {
                    audioChunks = [];
                    mediaRecorder.start();
                }
            }
        });

        // Clean up
        window.addEventListener('beforeunload', () => {
            if (processingTimeout) clearTimeout(processingTimeout);
            if (resultTimeout) clearTimeout(resultTimeout);
            deactivate();
            if (audioStream) {
                audioStream.getTracks().forEach(track => track.stop());
            }
            if (audioContext) {
                audioContext.close();
            }
        });

        // Get current settings from main process
        ipcRenderer.send('get-optimize-settings');
        ipcRenderer.send('get-theme');

        ipcRenderer.on('optimize-status-changed', (event, enabled) => {
            if (enabled) {
                optimizeIcon.classList.add('active');
            } else {
                optimizeIcon.classList.remove('active');
            }
        });

        ipcRenderer.on('current-theme', (event, theme) => {
            if (theme === 'light') {
                document.body.classList.add('light-theme');
            } else {
                document.body.classList.remove('light-theme');
            }
        });

        ipcRenderer.on('theme-changed', (event, theme) => {
            if (theme === 'light') {
                document.body.classList.add('light-theme');
            } else {
                document.body.classList.remove('light-theme');
            }
        });
    </script>
</body>
</html> 