<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>SonicText</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: transparent;
            color: var(--text-color, #ffffff);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            user-select: none;
            overflow: hidden;
            -webkit-app-region: drag;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            transition: color 0.3s;
        }

        :root {
            /* Dark theme (default) */
            --text-color: #ffffff;
            --text-secondary: rgba(255, 255, 255, 0.8);
            --text-hint: rgba(255, 255, 255, 0.5);
            --pill-bg: rgba(40, 40, 40, 0.9);
            --pill-shadow: rgba(0, 0, 0, 0.2);
            --icon-color: rgba(255, 255, 255, 0.7);
            --icon-hover: rgba(255, 255, 255, 0.9);
            --icon-active: #4a9eff;
            --result-bg: rgba(40, 40, 40, 0.9);
            --result-error: rgba(255, 60, 60, 0.9);
            --indicator-inactive: rgba(100, 100, 100, 0.5);
            --indicator-active: rgba(255, 0, 0, 0.7);
            --indicator-processing: rgba(255, 200, 0, 0.7);
            --visualizer-bar: rgba(255, 255, 255, 0.8);
            --visualizer-shadow: rgba(255, 255, 255, 0.3);
            --visualizer-shadow-active: rgba(255, 255, 255, 0.4);
        }

        body.light-theme {
            /* Light theme */
            --text-color: #2c2c2c;
            --text-secondary: rgba(0, 0, 0, 0.8);
            --text-hint: rgba(0, 0, 0, 0.6);
            --pill-bg: rgba(255, 255, 255, 0.9);
            --pill-shadow: rgba(0, 0, 0, 0.1);
            --icon-color: rgba(0, 0, 0, 0.6);
            --icon-hover: rgba(0, 0, 0, 0.8);
            --icon-active: #0066cc;
            --result-bg: rgba(255, 255, 255, 0.9);
            --result-error: rgba(255, 60, 60, 0.9);
            --indicator-inactive: rgba(200, 200, 200, 0.5);
            --indicator-active: rgba(255, 0, 0, 0.7);
            --indicator-processing: rgba(255, 200, 0, 0.7);
            --visualizer-bar: rgba(0, 0, 0, 0.7);
            --visualizer-shadow: rgba(0, 0, 0, 0.2);
            --visualizer-shadow-active: rgba(0, 0, 0, 0.3);
        }

        .status-pill {
            background: var(--pill-bg);
            border-radius: 20px;
            padding: 4px 20px 4px 4px;
            display: flex;
            align-items: center;
            min-width: 350px;
            height: 28px;
            box-shadow: 0 2px 8px var(--pill-shadow);
            margin: 10px 0;
            position: relative;
        }

        #settings-icon, #optimize-icon, #history-icon {
            position: absolute;
            width: 14px;
            height: 14px;
            fill: var(--icon-color);
            cursor: pointer;
            transition: all 0.2s;
            -webkit-app-region: no-drag;
        }

        #settings-icon:hover, #optimize-icon:hover, #history-icon:hover {
            fill: var(--icon-hover);
        }

        #optimize-icon.active {
            fill: var(--icon-active);
            filter: drop-shadow(0 0 4px rgba(74, 158, 255, 0.5));
        }

        .result-box {
            background: var(--result-bg);
            border-radius: 10px;
            padding: 8px 12px;
            margin-top: 5px;
            max-width: 600px;
            min-width: 300px;
            font-size: 12px;
            color: var(--text-color);
            display: none;
            text-align: center;
            white-space: pre-wrap;
            word-break: break-word;
            line-height: 1.4;
            box-shadow: 0 2px 8px var(--pill-shadow);
            -webkit-app-region: no-drag;
        }

        .result-box.error {
            background: var(--result-error);
            color: #ffffff;
        }

        #indicator {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: var(--indicator-inactive);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
            margin-right: auto;
        }

        #indicator.active {
            background: var(--indicator-active);
            transform: scale(1.05);
        }

        #indicator.processing {
            background: var(--indicator-processing);
        }

        #mic-icon {
            width: 16px;
            height: 16px;
            fill: var(--text-color);
            opacity: 0.7;
            transition: opacity 0.1s ease;
        }

        #status-text {
            color: var(--text-secondary);
            font-size: 13px;
            font-weight: 500;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }

        .visualizer-bar {
            width: 3px;
            height: 2px;
            background: var(--visualizer-bar);
            border-radius: 1px;
            transition: height 0.1s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 0.1s ease;
            box-shadow: 0 0 4px var(--visualizer-shadow);
        }

        #visualizer.active .visualizer-bar {
            box-shadow: 0 0 6px var(--visualizer-shadow-active);
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 8px var(--indicator-processing); }
            50% { box-shadow: 0 0 16px var(--indicator-processing); }
            100% { box-shadow: 0 0 8px var(--indicator-processing); }
        }

        #indicator.processing {
            animation: pulse 1.5s ease-in-out infinite;
        }

        #settings-icon {
            right: 6px;
            top: 50%;
            transform: translateY(-50%);
        }

        #history-icon {
            right: 28px;
            top: 50%;
            transform: translateY(-50%);
        }

        #optimize-icon {
            right: 50px;
            top: 50%;
            transform: translateY(-50%);
        }

        .result-box.visible {
            display: block;
        }

        #visualizer {
            display: none;
            height: 20px;
            align-items: center;
            gap: 3px;
            position: absolute;
            left: 52%;
            transform: translateX(-50%);
        }

        #visualizer.active {
            display: flex;
        }

        #indicator.active #mic-icon,
        #indicator.processing #mic-icon {
            opacity: 1;
        }

        body.light-theme #optimize-icon.active {
            filter: drop-shadow(0 0 4px rgba(0, 102, 204, 0.5));
        }

        body.light-theme .mode-select {
            background-image: url('data:image/svg+xml;utf8,<svg fill="black" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/></svg>');
        }
    </style>
</head>
<body>
    <div class="status-pill">
        <div id="indicator">
            <svg id="mic-icon" viewBox="0 0 24 24">
                <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm-1-9c0-.55.45-1 1-1s1 .45 1 1v6c0 .55-.45 1-1 1s-1-.45-1-1V5z"/>
                <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>
            </svg>
        </div>
        <div id="visualizer">
            <div class="visualizer-bar"></div>
            <div class="visualizer-bar"></div>
            <div class="visualizer-bar"></div>
            <div class="visualizer-bar"></div>
            <div class="visualizer-bar"></div>
        </div>
        <span id="status-text">Waiting...</span>
        <svg id="optimize-icon" viewBox="0 0 24 24">
            <path d="M12.6 2.4c-.4-.3-.9-.3-1.2 0C9.5 3.9 8 6.2 8 9c0 1.1.3 2.1.8 3H6c-.6 0-1 .4-1 1v2c0 .6.4 1 1 1h1v2c0 .6.4 1 1 1h2v2c0 .6.4 1 1 1h2c.6 0 1-.4 1-1v-2h2c.6 0 1-.4 1-1v-2h1c.6 0 1-.4 1-1v-2c0-.6-.4-1-1-1h-2.8c.5-.9.8-1.9.8-3 0-2.8-1.5-5.1-3.4-6.6zM12 8c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2z"/>
        </svg>
        <svg id="history-icon" viewBox="0 0 24 24">
            <path d="M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z"/>
        </svg>
        <svg id="settings-icon" viewBox="0 0 24 24">
            <path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/>
        </svg>
    </div>
    <div id="result" class="result-box"></div>
    <script>
        const { ipcRenderer } = require('electron');
        const indicator = document.getElementById('indicator');
        const statusText = document.getElementById('status-text');
        let isActive = false;
        let isProcessing = false;
        let audioContext = null;
        let analyser = null;
        let microphone = null;
        let animationFrame = null;
        let mediaRecorder = null;
        let audioChunks = [];
        let audioStream = null;
        let lastVolume = 0;
        let processingTimeout = null;
        let currentDeviceId = '';

        async function setupAudio() {
            try {
                if (audioStream) {
                    audioStream.getTracks().forEach(track => track.stop());
                }
                
                const constraints = { 
                    audio: {
                        channelCount: 1,
                        sampleRate: 16000,
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: false
                    } 
                };

                // If we have a specific device selected, use it
                if (currentDeviceId) {
                    constraints.audio = {
                        ...constraints.audio,
                        deviceId: { exact: currentDeviceId }
                    };
                }
                
                audioStream = await navigator.mediaDevices.getUserMedia(constraints);
                
                if (audioContext) {
                    await audioContext.close();
                }
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                microphone = audioContext.createMediaStreamSource(audioStream);
                
                analyser.fftSize = 512;
                analyser.smoothingTimeConstant = 0.6;
                microphone.connect(analyser);

                mediaRecorder = new MediaRecorder(audioStream, {
                    mimeType: 'audio/webm',
                    audioBitsPerSecond: 128000
                });

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = async () => {
                    if (audioChunks.length > 0) {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        startProcessing();
                        
                        const arrayBuffer = await audioBlob.arrayBuffer();
                        const buffer = Buffer.from(arrayBuffer);
                        ipcRenderer.send('audio-recorded', buffer);
                        
                        audioChunks = [];
                    }
                };
                
                return true;
            } catch (error) {
                console.error('Error accessing microphone:', error);
                return false;
            }
        }

        function updateGlow() {
            if (!isActive || !analyser) return;

            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(dataArray);
            
            const voiceRange = dataArray.slice(1, 6);
            const average = voiceRange.reduce((a, b) => a + b) / voiceRange.length;
            
            const normalizedVolume = Math.pow(average / 128, 1.8);
            // Adjust smoothing ratio to favor new values more when volume is decreasing
            const smoothingRatio = normalizedVolume < lastVolume ? 0.6 : 0.4;
            const smoothedVolume = normalizedVolume * smoothingRatio + lastVolume * (1 - smoothingRatio);
            lastVolume = smoothedVolume;

            // Update visualizer bars with smoother transitions
            const bars = document.querySelectorAll('.visualizer-bar');
            const numBars = bars.length;
            for (let i = 0; i < numBars; i++) {
                const barIndex = Math.floor(i * (voiceRange.length / numBars));
                const value = voiceRange[barIndex] / 255;
                const targetHeight = Math.max(2, Math.min(32, value * 40));
                const currentHeight = parseFloat(bars[i].style.height) || 2;
                const heightSmoothingRatio = targetHeight < currentHeight ? 0.7 : 0.4;
                const smoothedHeight = currentHeight * (1 - heightSmoothingRatio) + targetHeight * heightSmoothingRatio;
                bars[i].style.height = `${smoothedHeight}px`;
                
                // Adjust glow intensity based on height
                const glowIntensity = (smoothedHeight - 2) / 30; // normalized 0-1 based on height
                const glowOpacity = 0.3 + (glowIntensity * 0.3); // range from 0.3 to 0.6
                const glowSize = 4 + (glowIntensity * 4); // range from 4px to 8px
                bars[i].style.boxShadow = `0 0 ${glowSize}px rgba(255, 255, 255, ${glowOpacity})`;
            }

            const minGlow = 8;
            const maxGlow = 20;
            const glowAmount = minGlow + (maxGlow * smoothedVolume);
            const minOpacity = 0.3;
            const maxOpacity = 0.8;
            const opacity = minOpacity + ((maxOpacity - minOpacity) * smoothedVolume);
            
            if (!isProcessing) {
                indicator.style.boxShadow = `0 0 ${glowAmount}px rgba(255, 0, 0, ${opacity})`;
            }

            if (isActive) {
                animationFrame = requestAnimationFrame(updateGlow);
            }
        }

        function startProcessing() {
            isProcessing = true;
            statusText.textContent = 'Processing...';
            indicator.classList.add('processing');
            
            // Simulate processing time (remove this when implementing actual API)
            processingTimeout = setTimeout(() => {
                endProcessing();
            }, 3000);
        }

        function endProcessing() {
            isProcessing = false;
            statusText.textContent = 'Waiting...';
            indicator.classList.remove('processing');
            indicator.style.boxShadow = 'none';
        }

        async function activate() {
            if (!isActive && !isProcessing) {
                isActive = true;
                statusText.style.display = 'none';
                document.getElementById('visualizer').classList.add('active');
                indicator.classList.add('active');
                
                try {
                    if (!audioContext || !mediaRecorder) {
                        await setupAudio();
                    } else if (audioContext.state === 'suspended') {
                        await audioContext.resume();
                    }
                    
                    if (mediaRecorder && mediaRecorder.state === 'inactive') {
                        audioChunks = [];
                        mediaRecorder.start();
                        updateGlow();
                    }
                } catch (error) {
                    console.error('Error activating audio:', error);
                    deactivate();
                }
            }
        }

        function deactivate() {
            if (isActive) {
                isActive = false;
                statusText.style.display = 'inline';
                document.getElementById('visualizer').classList.remove('active');
                indicator.classList.remove('active');
                
                // Reset visualizer bars
                const bars = document.querySelectorAll('.visualizer-bar');
                bars.forEach(bar => bar.style.height = '2px');
                
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                }
                
                if (animationFrame) {
                    cancelAnimationFrame(animationFrame);
                    animationFrame = null;
                }
                
                if (audioContext && audioContext.state === 'running') {
                    audioContext.suspend();
                }
            }
        }

        ipcRenderer.on('hotkey-pressed', activate);
        ipcRenderer.on('hotkey-released', deactivate);

        // Add result box handling
        const resultBox = document.getElementById('result');
        let resultTimeout = null;

        ipcRenderer.on('transcription-start', () => {
            statusText.textContent = 'Transcribing...';
            resultBox.classList.remove('error');
            resultBox.classList.add('visible');
        });

        ipcRenderer.on('optimization-start', () => {
            statusText.textContent = 'Optimizing...';
        });

        ipcRenderer.on('optimization-complete', () => {
            endProcessing();
        });

        ipcRenderer.on('optimization-error', (event, error) => {
            console.error('Optimization error:', error);
            endProcessing();
        });

        ipcRenderer.on('transcription-result', (event, text) => {
            resultBox.textContent = text;
            
            // Adjust window height based on content
            const totalHeight = document.body.scrollHeight + 20; // Add padding
            const maxHeight = 500;
            const newHeight = Math.min(totalHeight, maxHeight);
            ipcRenderer.send('adjust-window-height', newHeight);
            
            // Start hide timer if we're not optimizing
            if (!statusText.textContent.includes('Optimizing')) {
                if (resultTimeout) clearTimeout(resultTimeout);
                resultTimeout = setTimeout(() => {
                    resultBox.classList.remove('visible');
                    ipcRenderer.send('adjust-window-height', 100); // Reset to original height
                }, 15000); // Increased from 5000 to 15000 (15 seconds)
            }
        });

        ipcRenderer.on('transcription-error', (event, error) => {
            resultBox.textContent = `Error: ${error}`;
            resultBox.classList.add('error', 'visible');
            endProcessing();
            
            // Hide error after 3 seconds
            if (resultTimeout) clearTimeout(resultTimeout);
            resultTimeout = setTimeout(() => {
                resultBox.classList.remove('visible', 'error');
            }, 3000);
        });

        // Add settings icon click handler
        const settingsIcon = document.getElementById('settings-icon');
        const optimizeIcon = document.getElementById('optimize-icon');
        const historyIcon = document.getElementById('history-icon');
        
        settingsIcon.addEventListener('click', () => {
            ipcRenderer.send('toggle-settings');
        });

        optimizeIcon.addEventListener('click', () => {
            ipcRenderer.send('toggle-optimize');
        });

        historyIcon.addEventListener('click', () => {
            ipcRenderer.send('toggle-history');
        });

        // Handle optimization status changes
        ipcRenderer.on('optimize-status-changed', (event, enabled) => {
            if (enabled) {
                optimizeIcon.classList.add('active');
            } else {
                optimizeIcon.classList.remove('active');
            }
        });

        // Get initial optimization status
        ipcRenderer.send('get-optimize-settings');
        ipcRenderer.on('optimize-settings', (event, settings) => {
            if (settings.enabled) {
                optimizeIcon.classList.add('active');
            } else {
                optimizeIcon.classList.remove('active');
            }
        });

        // Add device change handler
        ipcRenderer.on('device-changed', async (event, deviceId) => {
            currentDeviceId = deviceId;
            if (isActive) {
                // If we're currently recording, stop and restart with new device
                const wasRecording = mediaRecorder?.state === 'recording';
                if (wasRecording) {
                    mediaRecorder.stop();
                }
                await setupAudio();
                if (wasRecording) {
                    audioChunks = [];
                    mediaRecorder.start();
                }
            }
        });

        // Clean up
        window.addEventListener('beforeunload', () => {
            if (processingTimeout) clearTimeout(processingTimeout);
            if (resultTimeout) clearTimeout(resultTimeout);
            deactivate();
            if (audioStream) {
                audioStream.getTracks().forEach(track => track.stop());
            }
            if (audioContext) {
                audioContext.close();
            }
        });

        // Get current settings from main process
        ipcRenderer.send('get-optimize-settings');
        ipcRenderer.send('get-theme');

        ipcRenderer.on('optimize-status-changed', (event, enabled) => {
            if (enabled) {
                optimizeIcon.classList.add('active');
            } else {
                optimizeIcon.classList.remove('active');
            }
        });

        ipcRenderer.on('current-theme', (event, theme) => {
            if (theme === 'light') {
                document.body.classList.add('light-theme');
            } else {
                document.body.classList.remove('light-theme');
            }
        });

        ipcRenderer.on('theme-changed', (event, theme) => {
            if (theme === 'light') {
                document.body.classList.add('light-theme');
            } else {
                document.body.classList.remove('light-theme');
            }
        });
    </script>
</body>
</html> 